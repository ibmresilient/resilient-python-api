# -*- coding: utf-8 -*-
# (c) Copyright IBM Corp. 2010. 2025. All Rights Reserved.
# pragma pylint: disable=line-too-long, wrong-import-order

import datetime
from . import constants
from . import common
from .interfaces import SpecificationSection

INFO_TITLE = "title"
INFO_DESCRIPTION = "description"
INFO_VERSION = "version"
INFO_DATE_MODIFIED = "x-date-modified"
INFO_DATE_GENERATED = "x-date-generated"

class Info(SpecificationSection):
    def __init__(self,
                 is_soar: bool,
                 is_terse: bool,
                 spec: dict = {}):
        super().__init__(is_soar,
                         is_terse,
                         constants.SPEC_INFO_PATH,
                         spec_default=None,
                         spec=spec)
        self.import_section(spec)

    @property
    def name(self) -> str:
        return self._title if self._title else "Unknown"

    @property
    def version(self) -> str:
        return self._version

    # override from SpecificationSection
    def display_existing_section(self) -> list:
        """ Description fields can be very long. This module truncates the description to 1000 characters"""
        section = dict(self.section)
        # description fields can be very long. Truncate the output
        if section.get("description"):
            section["description"] = f"{section['description'][:1000]} ... (truncated)"

        return [f"{key}: {value}" for key, value in section.items()]

    def prompt_section(self) -> None:
        """ Get all the information needed for the Endpoint solution:
            - Name
            - Description
            - Document version
        """
        prompt = "Name the integration solution."
        if self.is_soar:
            prompt = f"{prompt} This will be used as the low-code connector app name."

        example = "IBM Guardium Insights"

        self._title = common.prompt_input(prompt,
                                         example=example,
                                         default=self._title)
        self._description = common.prompt_input("Enter an optional description",
                                                required=False,
                                                default=self._description if self._description else f"Generated by {constants.TOOL_NAME}")

        self._version = common.prompt_input("Enter this document's version.",
                                          default=self._version if self._version else constants.DEFAULT_DOC_VERSION)

    # override from SpecificationSection
    def import_section(self, spec: dict) -> None:
        """From an existing OpenAPI spec document, import the info section

        :param spec: original OpenAPI spec document
        :type spec: dict
        """
        info_spec = spec.get("info", {})
        ts = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        self._title = info_spec.get(INFO_TITLE)
        self._description = info_spec.get(INFO_DESCRIPTION)
        self._version = info_spec.get(INFO_VERSION, constants.DEFAULT_DOC_VERSION)
        self._create_date = info_spec.get(INFO_DATE_GENERATED, ts)
        self._update_date = ts

    def export_section(self) -> dict:
        """build an Info section for an OpenAPI spec document

        :return: Info section
        :rtype: dict
        """
        new_info = {
                INFO_TITLE: self._title,
                INFO_DESCRIPTION: self._description,
                INFO_VERSION: self._version,
                INFO_DATE_GENERATED: self._create_date,
                INFO_DATE_MODIFIED: self._update_date
        }

        # merge the data, retaining the original info but replacing our tracked settings
        return {**self.section, **new_info}

def validate_version(version: str) -> bool:
    """ version can be in format major.minor.patch format, all digits.
        But I've seen labels, such as 'latest'. So, this is currently not used.
    """

    version_set = version.split(".")
    if len(version_set) == 3:
        for item in version_set:
            if not item.isdigit():
                return False
        return True

    return False
